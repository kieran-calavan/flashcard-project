{"ast":null,"code":"import _asyncToGenerator from \"/Users/kieran/Documents/GitHub/flashcard-project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectWithoutProperties from \"/Users/kieran/Documents/GitHub/flashcard-project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\n/**\n * Defines the base URL for the API.\n * The default values is overridden by the `API_BASE_URL` environment variable.\n */\nvar API_BASE_URL = process.env.API_BASE_URL || \"http://localhost:8080\";\n/**\n * Defines the default headers for these functions to work with `json-server`\n */\n\nvar headers = new Headers();\nheaders.append(\"Content-Type\", \"application/json\");\n/**\n * Removes the `cards` property from the deck so it is not accidentally saved with the deck.\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param deck\n *  the deck instance\n * @returns {*}\n *  a copy of the deck instance with the `cards` property removed.\n */\n\nfunction stripCards(deck) {\n  var cards = deck.cards,\n      deckWithoutCards = _objectWithoutProperties(deck, [\"cards\"]);\n\n  return deckWithoutCards;\n}\n/**\n * Fetch `json` from the specified URL and handle error status codes and ignore `AbortError`s\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param url\n *  the url for the requst.\n * @param options\n *  any options for fetch\n * @param onCancel\n *  default value returned if the fetch is cancelled.\n * @returns {Promise<Error|any>}\n *  a promise that resolves to the `json` data or an error.\n *  If the response is not in the 200 - 399 range the promise is rejected.\n */\n\n\nfunction fetchJson(_x, _x2, _x3) {\n  return _fetchJson.apply(this, arguments);\n}\n/**\n * Retrieves all existing decks.\n * @returns {Promise<[deck]>}\n *  a promise that resolves to a possibly empty array of decks saved in the database.\n */\n\n\nfunction _fetchJson() {\n  _fetchJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, options, onCancel) {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return fetch(url, options);\n\n          case 3:\n            response = _context.sent;\n\n            if (!(response.status < 200 || response.status > 399)) {\n              _context.next = 6;\n              break;\n            }\n\n            throw new Error(\"\".concat(response.status, \" - \").concat(response.statusText));\n\n          case 6:\n            if (!(response.status === 204)) {\n              _context.next = 8;\n              break;\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 8:\n            _context.next = 10;\n            return response.json();\n\n          case 10:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](0);\n\n            if (!(_context.t0.name !== \"AbortError\")) {\n              _context.next = 18;\n              break;\n            }\n\n            console.error(_context.t0.stack);\n            throw _context.t0;\n\n          case 18:\n            return _context.abrupt(\"return\", Promise.resolve(onCancel));\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 13]]);\n  }));\n  return _fetchJson.apply(this, arguments);\n}\n\nexport function listDecks(_x4) {\n  return _listDecks.apply(this, arguments);\n}\n/**\n * Saves deck to the database (public/data/db.json).\n * There is no validation done on the deck object, any object will be saved.\n * @param deck\n *  the deck to save, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<deck>}\n *  a promise that resolves the saved deck, which will now have an `id` property.\n */\n\nfunction _listDecks() {\n  _listDecks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signal) {\n    var url;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            url = \"\".concat(API_BASE_URL, \"/decks?_embed=cards\");\n            _context2.next = 3;\n            return fetchJson(url, {\n              signal: signal\n            }, []);\n\n          case 3:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _listDecks.apply(this, arguments);\n}\n\nexport function createDeck(_x5, _x6) {\n  return _createDeck.apply(this, arguments);\n}\n/**\n * Retrieves the deck with the specified `deckId`\n * @param deckId\n *  the `id` property matching the desired deck.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<any>}\n *  a promise that resolves to the saved deck.\n */\n\nfunction _createDeck() {\n  _createDeck = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(deck, signal) {\n    var url, options;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            url = \"\".concat(API_BASE_URL, \"/decks\");\n            options = {\n              method: \"POST\",\n              headers: headers,\n              body: JSON.stringify(stripCards(deck)),\n              signal: signal\n            };\n            _context3.next = 4;\n            return fetchJson(url, options, {});\n\n          case 4:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _createDeck.apply(this, arguments);\n}\n\nexport function readDeck(_x7, _x8) {\n  return _readDeck.apply(this, arguments);\n}\n/**\n * Updates an existing deck\n * @param updatedDeck\n *  the deck to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated deck.\n */\n\nfunction _readDeck() {\n  _readDeck = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(deckId, signal) {\n    var url;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            url = \"\".concat(API_BASE_URL, \"/decks/\").concat(deckId, \"?_embed=cards\");\n            _context4.next = 3;\n            return fetchJson(url, {\n              signal: signal\n            }, {});\n\n          case 3:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _readDeck.apply(this, arguments);\n}\n\nexport function updateDeck(_x9, _x10) {\n  return _updateDeck.apply(this, arguments);\n}\n/**\n * Deletes the deck with the specified `deckId`.\n * @param deckId\n *  the id of the deck to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */\n\nfunction _updateDeck() {\n  _updateDeck = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(updatedDeck, signal) {\n    var url, options;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            url = \"\".concat(API_BASE_URL, \"/decks/\").concat(updatedDeck.id, \"?_embed=cards\");\n            options = {\n              method: \"PUT\",\n              headers: headers,\n              body: JSON.stringify(stripCards(updatedDeck)),\n              signal: signal\n            };\n            _context5.next = 4;\n            return fetchJson(url, options, updatedDeck);\n\n          case 4:\n            return _context5.abrupt(\"return\", _context5.sent);\n\n          case 5:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _updateDeck.apply(this, arguments);\n}\n\nexport function deleteDeck(_x11, _x12) {\n  return _deleteDeck.apply(this, arguments);\n}\n/**\n * Creates a new card associated with the specified `deckId`.\n * There is no validation that there is an existing deck with the specified `deckId`.\n * @param deckId\n *  the id of the target deck\n * @param card\n *  the card to create, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the new card, which will have an `id` property.\n */\n\nfunction _deleteDeck() {\n  _deleteDeck = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(deckId, signal) {\n    var url, options;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            url = \"\".concat(API_BASE_URL, \"/decks/\").concat(deckId);\n            options = {\n              method: \"DELETE\",\n              signal: signal\n            };\n            _context6.next = 4;\n            return fetchJson(url, options);\n\n          case 4:\n            return _context6.abrupt(\"return\", _context6.sent);\n\n          case 5:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _deleteDeck.apply(this, arguments);\n}\n\nexport function createCard(_x13, _x14, _x15) {\n  return _createCard.apply(this, arguments);\n}\n/**\n * Retrieves the card with the specified `cardId`\n * @param cardId\n *  the id of the target\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the saved card.\n */\n\nfunction _createCard() {\n  _createCard = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(deckId, card, signal) {\n    var url, options;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            // There is a bug in json-server, if you post to /decks/:deckId/cards the associated deckId is a string\n            // and the card is not related to the deck because the data types of the ID's are different.\n            url = \"\".concat(API_BASE_URL, \"/cards\");\n            card.deckId = Number(deckId);\n            options = {\n              method: \"POST\",\n              headers: headers,\n              body: JSON.stringify(card),\n              signal: signal\n            };\n            _context7.next = 5;\n            return fetchJson(url, options, card);\n\n          case 5:\n            return _context7.abrupt(\"return\", _context7.sent);\n\n          case 6:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _createCard.apply(this, arguments);\n}\n\nexport function readCard(_x16, _x17) {\n  return _readCard.apply(this, arguments);\n}\n/**\n * Updates an existing deck\n * @param updatedCard\n *  the card to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated card.\n */\n\nfunction _readCard() {\n  _readCard = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(cardId, signal) {\n    var url;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            url = \"\".concat(API_BASE_URL, \"/cards/\").concat(cardId);\n            _context8.next = 3;\n            return fetchJson(url, {\n              signal: signal\n            }, {});\n\n          case 3:\n            return _context8.abrupt(\"return\", _context8.sent);\n\n          case 4:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _readCard.apply(this, arguments);\n}\n\nexport function updateCard(_x18, _x19) {\n  return _updateCard.apply(this, arguments);\n}\n/**\n * Deletes the card with the specified `cardId`.\n * @param cardId\n *  the id of the card to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */\n\nfunction _updateCard() {\n  _updateCard = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(updatedCard, signal) {\n    var url, options;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            url = \"\".concat(API_BASE_URL, \"/cards/\").concat(updatedCard.id);\n            options = {\n              method: \"PUT\",\n              headers: headers,\n              body: JSON.stringify(updatedCard)\n            };\n            _context9.next = 4;\n            return fetchJson(url, options, updatedCard);\n\n          case 4:\n            return _context9.abrupt(\"return\", _context9.sent);\n\n          case 5:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _updateCard.apply(this, arguments);\n}\n\nexport function deleteCard(_x20, _x21) {\n  return _deleteCard.apply(this, arguments);\n}\n\nfunction _deleteCard() {\n  _deleteCard = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(cardId, signal) {\n    var url, options;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            url = \"\".concat(API_BASE_URL, \"/cards/\").concat(cardId);\n            options = {\n              method: \"DELETE\",\n              signal: signal\n            };\n            _context10.next = 4;\n            return fetchJson(url, options);\n\n          case 4:\n            return _context10.abrupt(\"return\", _context10.sent);\n\n          case 5:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n  return _deleteCard.apply(this, arguments);\n}","map":{"version":3,"names":["API_BASE_URL","process","env","headers","Headers","append","stripCards","deck","cards","deckWithoutCards","fetchJson","url","options","onCancel","fetch","response","status","Error","statusText","json","name","console","error","stack","Promise","resolve","listDecks","signal","createDeck","method","body","JSON","stringify","readDeck","deckId","updateDeck","updatedDeck","id","deleteDeck","createCard","card","Number","readCard","cardId","updateCard","updatedCard","deleteCard"],"sources":["/Users/kieran/Documents/GitHub/flashcard-project/src/utils/api/index.js"],"sourcesContent":["/**\n * Defines the base URL for the API.\n * The default values is overridden by the `API_BASE_URL` environment variable.\n */\nconst API_BASE_URL = process.env.API_BASE_URL || \"http://localhost:8080\";\n\n/**\n * Defines the default headers for these functions to work with `json-server`\n */\nconst headers = new Headers();\nheaders.append(\"Content-Type\", \"application/json\");\n\n/**\n * Removes the `cards` property from the deck so it is not accidentally saved with the deck.\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param deck\n *  the deck instance\n * @returns {*}\n *  a copy of the deck instance with the `cards` property removed.\n */\nfunction stripCards(deck) {\n  const { cards, ...deckWithoutCards } = deck;\n  return deckWithoutCards;\n}\n\n/**\n * Fetch `json` from the specified URL and handle error status codes and ignore `AbortError`s\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param url\n *  the url for the requst.\n * @param options\n *  any options for fetch\n * @param onCancel\n *  default value returned if the fetch is cancelled.\n * @returns {Promise<Error|any>}\n *  a promise that resolves to the `json` data or an error.\n *  If the response is not in the 200 - 399 range the promise is rejected.\n */\n\nasync function fetchJson(url, options, onCancel) {\n  try {\n    const response = await fetch(url, options);\n\n    if (response.status < 200 || response.status > 399) {\n      throw new Error(`${response.status} - ${response.statusText}`);\n    }\n\n    if (response.status === 204) {\n      return null;\n    }\n\n    return await response.json();\n\n  } catch (error) {\n    if (error.name !== \"AbortError\") {\n      console.error(error.stack);\n      throw error;\n    }\n    return Promise.resolve(onCancel);\n  }\n}\n\n/**\n * Retrieves all existing decks.\n * @returns {Promise<[deck]>}\n *  a promise that resolves to a possibly empty array of decks saved in the database.\n */\nexport async function listDecks(signal) {\n  const url = `${API_BASE_URL}/decks?_embed=cards`;\n  return await fetchJson(url, { signal }, []);\n}\n\n/**\n * Saves deck to the database (public/data/db.json).\n * There is no validation done on the deck object, any object will be saved.\n * @param deck\n *  the deck to save, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<deck>}\n *  a promise that resolves the saved deck, which will now have an `id` property.\n */\nexport async function createDeck(deck, signal) {\n  const url = `${API_BASE_URL}/decks`;\n  const options = {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(stripCards(deck)),\n    signal,\n  };\n  return await fetchJson(url, options, {});\n}\n\n/**\n * Retrieves the deck with the specified `deckId`\n * @param deckId\n *  the `id` property matching the desired deck.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<any>}\n *  a promise that resolves to the saved deck.\n */\nexport async function readDeck(deckId, signal) {\n  const url = `${API_BASE_URL}/decks/${deckId}?_embed=cards`;\n  return await fetchJson(url, { signal }, {});\n}\n\n/**\n * Updates an existing deck\n * @param updatedDeck\n *  the deck to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated deck.\n */\nexport async function updateDeck(updatedDeck, signal) {\n  const url = `${API_BASE_URL}/decks/${updatedDeck.id}?_embed=cards`;\n  const options = {\n    method: \"PUT\",\n    headers,\n    body: JSON.stringify(stripCards(updatedDeck)),\n    signal,\n  };\n  return await fetchJson(url, options, updatedDeck);\n}\n\n/**\n * Deletes the deck with the specified `deckId`.\n * @param deckId\n *  the id of the deck to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */\nexport async function deleteDeck(deckId, signal) {\n  const url = `${API_BASE_URL}/decks/${deckId}`;\n  const options = { method: \"DELETE\", signal };\n  return await fetchJson(url, options);\n}\n\n/**\n * Creates a new card associated with the specified `deckId`.\n * There is no validation that there is an existing deck with the specified `deckId`.\n * @param deckId\n *  the id of the target deck\n * @param card\n *  the card to create, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the new card, which will have an `id` property.\n */\nexport async function createCard(deckId, card, signal) {\n  // There is a bug in json-server, if you post to /decks/:deckId/cards the associated deckId is a string\n  // and the card is not related to the deck because the data types of the ID's are different.\n  const url = `${API_BASE_URL}/cards`;\n  card.deckId = Number(deckId);\n  const options = {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(card),\n    signal,\n  };\n  return await fetchJson(url, options, card);\n}\n\n/**\n * Retrieves the card with the specified `cardId`\n * @param cardId\n *  the id of the target\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the saved card.\n */\nexport async function readCard(cardId, signal) {\n  const url = `${API_BASE_URL}/cards/${cardId}`;\n  return await fetchJson(url, { signal }, {});\n}\n\n/**\n * Updates an existing deck\n * @param updatedCard\n *  the card to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated card.\n */\nexport async function updateCard(updatedCard, signal) {\n  const url = `${API_BASE_URL}/cards/${updatedCard.id}`;\n  const options = {\n    method: \"PUT\",\n    headers,\n    body: JSON.stringify(updatedCard),\n  };\n  return await fetchJson(url, options, updatedCard);\n}\n\n/**\n * Deletes the card with the specified `cardId`.\n * @param cardId\n *  the id of the card to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */\nexport async function deleteCard(cardId, signal) {\n  const url = `${API_BASE_URL}/cards/${cardId}`;\n  const options = { method: \"DELETE\", signal };\n  return await fetchJson(url, options);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}